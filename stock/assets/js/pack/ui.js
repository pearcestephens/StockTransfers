// UI and DOM interaction mixin
export const UIMixin = Base => class extends Base {
  bindEvents(){ if(this._eventsBound) return; this._eventsBound=true; document.addEventListener('input', e=>{ const t=e.target; if(t.matches('.qty-input, input[name^="counted_qty"]')){ this.updateRowStatus(t); this.updateTotals(); this.modules.autoSave?.triggerSave(); } else if(t.id==='notesForTransfer' || t.name==='notes'){ this.modules.autoSave?.triggerSave(); } else if(t.id==='productSearchInput'){ this.handleProductSearch(t.value.trim()); } });
    document.addEventListener('click', e=>{ if(e.target.matches('#autofillBtn')||e.target.closest?.('#autofillBtn')){ e.preventDefault(); this.autofillQuantities(); } else if(e.target.matches('#resetBtn')||e.target.closest?.('#resetBtn')){ e.preventDefault(); this.resetQuantities(); } else if(e.target.matches('#lockDiagnosticBtn')||e.target.closest?.('#lockDiagnosticBtn')){ e.preventDefault(); this.showLockDiagnostic?.(); } else if(e.target.matches('#headerAddProductBtn')||e.target.closest?.('#headerAddProductBtn')){ e.preventDefault(); this.openAddProductModal(); } else if(e.target.matches('#clearSearchBtn')||e.target.closest?.('#clearSearchBtn')){ e.preventDefault(); this.clearProductSearch(); } else if(e.target.matches('.add-product-btn')){ e.preventDefault(); this.addProductToTransfer(e.target); } });
    document.querySelectorAll('.qty-input, input[name^="counted_qty"]').forEach(input=>{ if(input.value){ const row=input.closest('tr'); this.validateRowColors(row); } });
    try{ this.updateTotals(); }catch{}
    this.debug('âœ… Event handlers bound (modular)'); }
  updateRowStatus(input){ if(!input) return; this._autoAcquireTried=false; const counted=parseInt(input.value,10)||0; const planned=parseInt(input.dataset.planned||input.getAttribute('data-planned'),10)||0; const row=input.closest('tr'); if(!row) return; row.classList.remove('qty-match','qty-mismatch','qty-neutral'); if(counted===planned && counted>0) row.classList.add('qty-match'); else if(counted!==planned && (counted>0 || planned>0)) row.classList.add('qty-mismatch'); else row.classList.add('qty-neutral'); const badge=row.querySelector('.badge'); if(badge){ if(counted===planned && counted>0){ badge.className='badge badge-success'; badge.textContent='Complete'; } else if(counted>planned){ badge.className='badge badge-warning'; badge.textContent='Over'; } else if(counted>0){ badge.className='badge badge-info'; badge.textContent='Partial'; } else { badge.className='badge badge-secondary'; badge.textContent='Pending'; } } }
  updateTotals(){ const inputs=document.querySelectorAll('.qty-input, input[name^="counted_qty"]'); let countedTotal=0, plannedTotal=0; inputs.forEach(i=>{ const qty=parseInt(i.value)||0; countedTotal+=qty; const planned=parseInt(i.dataset.planned||0); plannedTotal+=planned; const row=i.closest('tr'); this.validateRowColors(row); }); const countedFooter=document.querySelector('#countedTotalFooter'); const diffFooter=document.querySelector('#diffTotalFooter'); if(countedFooter) countedFooter.textContent=countedTotal; if(diffFooter){ const diff=countedTotal-plannedTotal; diffFooter.textContent= diff>0?`+${diff}`:diff.toString(); diffFooter.className= diff===0?'text-success': (diff>0?'text-warning':'text-danger'); } this.debug('Totals updated (modular):',{countedTotal,plannedTotal,diff:countedTotal-plannedTotal}); }
  validateRowColors(row){ if(!row) return; const input=row.querySelector('.qty-input, input[name^="counted_qty"]'); if(!input) return; const counted=parseInt(input.value)||0; const planned=parseInt(input.dataset.planned||0); row.classList.remove('table-success','table-danger','table-warning'); if(counted===0) return; if(counted===planned) row.classList.add('table-success'); else row.classList.add('table-danger'); }
  autofillQuantities(){ if(this.modules.lockSystem && !this.modules.lockSystem.lockStatus?.has_lock){ this.showToast?.('You need lock access to modify quantities','warning'); return; } const btn=document.querySelector('#autofillBtn'); if(btn){ btn.disabled=true; btn.innerHTML='<i class="fa fa-spinner fa-spin mr-1"></i>Filling...'; } let filled=0; document.querySelectorAll('.qty-input, input[name^="counted_qty"]').forEach(input=>{ const planned=parseInt(input.dataset.planned||0); if(planned>0){ input.value=planned; input.dispatchEvent(new Event('input',{bubbles:true})); this.validateRowColors(input.closest('tr')); filled++; } }); setTimeout(()=>{ if(btn){ btn.disabled=false; btn.innerHTML='<i class="fa fa-magic mr-1"></i>Autofill'; } },1000); this.showToast?.(`Autofilled ${filled} quantities with planned amounts`,'success'); this.updateTotals(); this.modules.autoSave?.triggerSave(); this.debug(`Autofilled ${filled} quantities (modular)`); }
  resetQuantities(){ if(this.modules.lockSystem && !this.modules.lockSystem.lockStatus?.has_lock){ this.showToast?.('You need lock access to modify quantities','warning'); return; } const btn=document.querySelector('#resetBtn'); if(btn){ btn.disabled=true; btn.innerHTML='<i class="fa fa-spinner fa-spin mr-1"></i>Resetting...'; } let reset=0; document.querySelectorAll('.qty-input, input[name^="counted_qty"]').forEach(input=>{ if(input.value && input.value!=='0'){ input.value=''; input.placeholder='0'; input.dispatchEvent(new Event('input',{bubbles:true})); this.validateRowColors(input.closest('tr')); reset++; } }); setTimeout(()=>{ if(btn){ btn.disabled=false; btn.innerHTML='<i class="fa fa-undo mr-1"></i>Reset'; } },1000); this.showToast?.(`Reset ${reset} quantity fields`,'info'); this.updateTotals(); this.modules.autoSave?.triggerSave(); this.debug(`Reset ${reset} quantities (modular)`); }
};
